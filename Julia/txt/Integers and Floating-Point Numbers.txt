Int8
UInt8
Int16
UInt16
Int32
UInt32
Int64
UInt64
Int128
UInt128
Bool

Float16
Float32
Float64


bellows will be Int64 on 64 bit system
typeof(1) <- return data type
Sys.WORD_SIZE
Int
UInt

0x1 <- Hexadecimal. Data type is Unsigned integer
0b10 <- Binary. Data type is also UInt
0o010 <- Octal. Data type is also UInt
-0x2 <- equal as 0xfe
-0x0002 <- equal as 0fffe

typemin(Int32) <- minimum value of the data type
typemax(Int32) <- maximum value of the data type

for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]
      println("$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]")
end
x=typemax(Int64)
x+1->overflow
x+1==typemax(Int64) ->True
10^19 -> overflow
big(10)^19 ->BigInt

Division errors
lowest negative number(typemin)/-1 -> 소수점이 생긴다?

1.0 -> 1.0 Float64
1. -> 1.0 Float64
0.5 -> 0.5 Float64
.5 -> 0.5 Float64
0.5f0 -> Float32
2.5f-4 -> Float32

0x1p0 -> 1.0 Float64 Hexadecimal floating-point
0x1.8p3->12
0x4p-1 ->0.125

sizeof(Float16(4.)) -> 2 Float16
2*Float16(4.) -> Float16(8.0)

0.0 == -0.0
bitstring(0.0) <> bitstring(-0.0) <- binary representation is different


Special floating-point values
Float16     Float32     Float64
Inf16       Inf32       Inf    :positive infinity
-Inf16      -Inf43      -Inf   :negative infinity
NaN16       NaN32       NaN    :Not a Number

1/Inf -> 0.0
1/0 -> Inf
-5/0 -> -Inf
0/0 -> NaN
Inf - Inf -> NaN
Inf * Inf -> Inf
Inf / Inf -> NaN
0 * Inf -> NaN

(typemin(Float16), typemax(Float16)) -> (-Inf16, Inf16)

Machine Epsilon
eps(Float32) <- floating-point value의 오차
eps() <- same as eps(Float64) and eps(1.0)
x + eps(x) is the next value of floating-point value x
eps(1.0) < eps(1000.0)
nextfloat(x)
prevfloat(x)
bitstring(prevfloat(x))
bitstring(nextfloat(x)) -> 1bit 차이


BigInt(typemax(Int64)) + 1
big"123456789012345678901234567890" + 1
parse(BigInt, "123456789012345678901234567890") + 1
big"1.23456789012345678901"
parse(BigInt, "1.23456789012345678901")
BigFloat(2.0^66) / 3
factorial(BigInt(40))

x = typemin(Int64)
x = x - 1
typeof(x) -> Int64
y = BigInt(typemin(Int64))
y = y - 1
typeof(y) -> BigInt

setrounding(BigFloat, RoundDown) -> 반올림 모드를 전역적 선언
setrounding(BigFloat, RoundUp) do -> 반올림 모드를 국지적 사용
      BigFloat(1) + parse(BigFloat, "0.1")
end

x = 3
2x^2 - 3x + 1 -> wow
1.5x^2 - .5x + 1

2^2x -> 지수함수
우선순위
-2x -> (-2) * x
√2x -> (√2) * x
2^3x -> (2)^(3x)
2x^3 -> 2*(x^3)

2(x-1)^2-3(x-1)+1 <- 위 룰은 괄호로 묶인 식에 대해서도 동일하게 적용
(x-1)x -> 가능
(x-1)(x+1) -> 불가능 함수로서 취급됨
x(x-1) -> 불가능 함수로서 취급됨

literal zero and one
zero(x)
one(x)
zero(Float32)->0.0f0
zero(1.0) -> 0.0
one(Int32) -> 1
one(BigFloat) -> 1.0
